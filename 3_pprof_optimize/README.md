# Week 3: parallel pipeline

## Запуск

```
# Собираем бенчмарки без GC
$ GOGC=off go test -bench . -benchmem -cpuprofile cpu.out 

# Визуализация в браузере
go tool pprof -http=:8083 hw3.test cpu.out  

```

## Оптимизации

Горячие места: regexp MatchString 57.50%, json Unmarshal 30.90%

1) Заменил динамическую структуру map[string]interface{} на фиксированную, сгенерированную по тестовым данным через https://mholt.github.io/json-to-go/: x1.37 speed up, x1.21 less allocs
```
BenchmarkSlow-8               60          24663395 ns/op        19837236 B/op     189731 allocs/op
BenchmarkFast-8               58          17955997 ns/op        19515451 B/op     155814 allocs/op

```

2) Заменил encoding/json на easyjson: x1.65 speed up, x1.27 less allocs
```
BenchmarkSlow-8               61          24395168 ns/op        19837351 B/op     189731 allocs/op
BenchmarkFast-8               78          14714402 ns/op        19128633 B/op     148814 allocs/op

```

Горячие места: regexp MatchString 83.90%, easyjson Unmarshal 3.39%. С unmarshal можно остановиться

3) Заменяем regexp на strings.Contains: x7.5 speed up, x14.8 less allocs
```
BenchmarkSlow-8               54          24320202 ns/op        19837374 B/op     189731 allocs/op
BenchmarkFast-8              500           3214775 ns/op         5623948 B/op      12814 allocs/op
```

Горячие места: browserChecker (метод где раньше был regexp) 12.32%, easyjson Unmarshal 38.41%. Уже особо ничего не пооптимизировать без параллельности.

4) Заменяем линейный поиск seenBrowsers на map[string]bool, убираем число циклов, лишние аллокации: x8.1 speed up
```
BenchmarkSlow-8               55          24856277 ns/op        19837355 B/op     189731 allocs/op
BenchmarkFast-8              546           3086202 ns/op         5229894 B/op      12804 allocs/op
```

## Исходное условие задания

Есть функция, которая что-то там ищет по файлу. Но делает она это не очень быстро. Надо её оптимизировать.

Задание на работу с профайлером pprof.

Цель задания - научиться работать с pprof, находить горячие места в коде, уметь строить профиль потребления cpu и памяти, оптимизировать код с учетом этой информации. Написание самого быстрого решения не является целью задания.

Для генерации графа вам понадобится graphviz. Для пользователей windows не забудьте добавить его в PATH чтобы была доступна команда dot.

Рекомендую внимательно прочитать доп. материалы на русском - там ещё много примеров оптимизации и объяснений как работать с профайлером. Фактически там есть вся информация для выполнения этого задания.

Есть с десяток мест, где можно оптимизировать.
Вам надо писать отчет, где вы заоптимайзили и что. Со скриншотами и объяснением что делали. Чтобы именно научиться в pprof находить проблемы, а не прикинуть мозгами и решить что вот тут медленно.

Для выполнения задания необходимо чтобы один из параметров ( ns/op, B/op, allocs/op ) был быстрее чем в *BenchmarkSolution* ( fast < solution ) и ещё один лучше *BenchmarkSolution* + 20% ( fast < solution * 1.2), например ( fast allocs/op < 10422*1.2=12506 ).

По памяти ( B/op ) и количеству аллокаций ( allocs/op ) можно ориентироваться ровно на результаты *BenchmarkSolution* ниже, по времени ( ns/op ) - нет, зависит от системы.

Параллелить (использовать горутины) или sync.Pool в это задании не нужно.

Результат в fast.go в функцию FastSearch (изначально там то же самое что в SlowSearch).

Пример результатов с которыми будет сравниваться:
```
$ go test -bench . -benchmem

goos: windows

goarch: amd64

BenchmarkSlow-8 10 142703250 ns/op 336887900 B/op 284175 allocs/op

BenchmarkSolution-8 500 2782432 ns/op 559910 B/op 10422 allocs/op

PASS

ok coursera/hw3 3.897s
```

Запуск:
* `go test -v` - чтобы проверить что ничего не сломалось
* `go test -bench . -benchmem` - для просмотра производительности
* `go tool pprof -http=:8083 /path/ho/bin /path/to/out` - веб-интерфейс для pprof, пользуйтесь им для поиска горячих мест. Не забывайте, что у вас 2 режиме - cpu и mem, там разные out-файлы.

Советы:
* Смотрите где мы аллоцируем память
* Смотрите где мы накапливаем весь результат, хотя нам все значения одновременно не нужны
* Смотрите где происходят преобразования типов, которые можно избежать
* Смотрите не только на графе, но и в pprof в текстовом виде (list FastSearch) - там прямо по исходнику можно увидеть где что
* Задание предполагает использование easyjson. На сервере эта библиотека есть, подключать можно. Но сгенерированный через easyjson код вам надо поместить в файл с вашей функцией
* Можно сделать без easyjson

Примечание:
* easyjson основан на рефлекции и не может работать с пакетом main. Для генерации кода вам необходимо вынести вашу структуру в отдельный пакет, сгенерить там код, потом забрать его в main
